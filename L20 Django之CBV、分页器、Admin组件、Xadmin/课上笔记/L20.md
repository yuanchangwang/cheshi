## L20

### 一. 今日概要

博客地址(FBV与CBV):<https://www.cnblogs.com/Michael--chen/p/10952134.html>

博客地址(分页器):<https://www.cnblogs.com/Michael--chen/p/10965465.html>

博客地址(admin):<https://www.cnblogs.com/Michael--chen/p/10971030.html>

博客地址(Xadmin):<https://www.cnblogs.com/Michael--chen/p/10971046.html>

1. FBV与CBV
2. 分页器
3. admin后台管理系统
4. Xadmin后台管理系统

### 二. 今日详细

1. FBV与CBV

   1. 写类视图

      1. 导入View

         ```python
         from django.views import View
         ```

      2. 写类视图

         ```python
         class Login(View):
             def get(self, request):
                 pass
             
             def post(self, request):
                 pass
             # 类下的方法名称,必须是Http请求方式的小写名称(不能是其他的名称)
         ```

      3. 路由层

         ```python
         path("login/", views.Login.as_view()),  # 一定要加上as_view()方法. 这里得到一个返回值(view函数)
         ```

         注意: CBV所有的请求进来,都会执行dispatch方法.

   2. 给CBV加上装饰器

      引入Django提供的method_decorator方法

      ```python
      from django.utils.decorators import method_decorator
      ```

      方式一:给单独的类下方法加

      ```python
      class Login(View):
          @methdo_decorator(timer)
          def get(self, request):
              pass
      ```

      方式二: 给dispatch方法加(给当前类下的所有方法都加上了装饰器)

      ```python
      class Login(View):
          @method_decorator(timer)
          def dispatch(self, request, *args, **kwargs):
              obj = super().dispatch(request, *args, **kwargs)
              return obj
          
          def get(self, request):
              pass
          
          def post(self, request):
              pass
      ```

      方式三:给类直接加上装饰器(一定要指定name参数,否则报错.参数值必须是该类下的方法名称)

      ```python
      @method_decorator(timer, name="get")
      class Login(View):
          def get(self, request):
              pass
      ```

2. 分页器

   1. Django自带的分页器

      基本语法:

      ```python
      # 实例化分页器对象
      paginator = Paginator(book_list, 10)  # 数字代表每页显示的数据条数
      paginator.count  # 数据的总数
      paginator.num_pages  # 分页的总页数
      paginator.page_range  # 页数的范围列表
      
      paginator.get_page(1)  # 获取第一页的所有数据 get_page内部做了异常处理,不会报错.内部本质还是调用self.page
      
      print(page2.has_next())  # 是否有下一页
      print(page2.next_page_number())  # 下一页的页码
      print(page2.has_previous())  # 是否有上一页
      print(page2.previous_page_number())  # 上一页的页码
      
      
      ```

      基本使用:

      参考一下课上代码或者是博客

      扩展:

      ```python
      # 我们按照页面显示11个页码为例。
      # 如果总页码大于11
      if paginator.num_pages > 11:
         if current_page - 5 < 1:  # 当前页小于中间页码时
             page_range = range(1, 12)
         elif current_page + 5 > paginator.num_pages:  # 当前页大于中间页码时
             page_range = range(paginator.num_pages - 10, paginator.num_pages + 1)
         else:
             page_range = range(current_page - 5, current_page + 6)
       else:
           page_range = paginator.page_range
      ```

   2. 自定制分页器(终极版本,好好保存)

      在app下新建一个py文件(utils.py)

      ```python 
      class Paginator:
          def __init__(self, request, current_page, all_count, per_page=10, max_page_num=11):
              """
              封装分页相关数据
              :param current_page:  当前页码
              :param all_count:  数据库中的数据总条数
              :param per_page:   每个页面显示的数据条数
              :param max_page_num:  最多显示的页码个数
              :param num_pages:  通过总条数/每个页面显示的条数，求出总页数
              """
              try:
                  current_page = int(current_page)
              except Exception as e:
                  current_page = 1
              if current_page < 1:
                  current_page = 1
              self.current_page = current_page
              self.all_count = all_count
              self.per_page = per_page
      
              # 计算总页数
              num_pages, temp = divmod(all_count, per_page)
              if temp:
                  num_pages += 1
              self.num_pages = num_pages
      
              self.max_page_num = max_page_num  # 11
              self.page_count_half = int((self.max_page_num - 1) / 2)  # 5
              """
              self.num_pages=100
              per_page=8
      
              current_page =1     [0:8]
              current_page =2     [8:16]
              current_page =3     [16:24]
                                  [(current_page-1)*per_page:current_page*per_page ]
      
              """
      
              import copy
              self.url_args = copy.deepcopy(request.GET)
              print(self.url_args.urlencode())
      
          @property
          def start(self):
              return (self.current_page - 1) * self.per_page
      
          @property
          def end(self):
              return self.current_page * self.per_page
      
          def page_html(self):
              # 如果总页数小于self.max_page_num(最多显示的页码个数)
              if self.num_pages <= self.max_page_num:
                  page_start = 1
                  page_end = self.num_pages + 1
              else:
                  # 如果当前页码<=页面上最多显示11/2个页码时
                  if self.current_page <= self.page_count_half:
                      page_start = 1
                      page_end = self.max_page_num + 1
                  # 如果当前页码+最多显示11/2 大于 总页数时
                  elif self.current_page + self.page_count_half > self.num_pages:
                      page_start = self.num_pages - self.max_page_num + 1
                      page_end = self.num_pages + 1
                  else:
                      page_start = self.current_page - self.page_count_half
                      page_end = self.current_page + self.page_count_half + 1
      
              page_html_list = []
      
              # 首页
              self.url_args['page'] = 1
              first_page = '<nav aria-label="Page navigation"><ul class="pagination"><li><a href="?%s">首页</a></li>' % self.url_args.urlencode()
              page_html_list.append(first_page)
      
              # 上一页
              if self.current_page <= 1:
                  prev_page = '<li class="disabled"><a href="javascript:void(0);">上一页</a></li>'
              else:
                  self.url_args['page'] = self.current_page - 1
                  prev_page = '<li><a href="?%s">上一页</a></li>' % self.url_args.urlencode()
              page_html_list.append(prev_page)
      
              # 显示页码
              for i in range(page_start, page_end):
                  self.url_args['page'] = i
                  if self.current_page == i:
                      temp = '<li class="active"><a href="?%s">%s</a></li>' % (self.url_args.urlencode(), i)
                  else:
                      temp = '<li><a href="?%s">%s</a></li>' % (self.url_args.urlencode(), i)
                  page_html_list.append(temp)
      
              # 下一页
              if self.current_page >= self.num_pages:
                  next_page = '<li class="disabled"><a href="javascript:void(0);">下一页</a></li>'
              else:
                  self.url_args['page'] = self.current_page + 1
                  next_page = '<li><a href="?%s">下一页</a></li>' % self.url_args.urlencode()
              page_html_list.append(next_page)
      
              # 尾页
              self.url_args['page'] = self.num_pages
              last_page = '<li><a href="?%s">尾页</a></li></ul></nav>' % self.url_args.urlencode()
              page_html_list.append(last_page)
      
              return "".join(page_html_list)
      ```

3. admin后台管理系统(Django自带的)

   1. 如果没有超级管理员用户，需要手动创建一个

      ```python 
      python3 manage.py createsuperuser
      ```

   2. 在app下的admin.py进行模型注册

      1. 方式一：(常用的)

         ```python 
         admin.site.register(models.Book, BookAdmin)  # 方式一 常用的方法
         ```

      2. 方式二：

         ```python 
         @admin.register(models.Book)  # 方式二 注册
         class BookAdmin(admin.ModelAdmin):
             pass
         ```

   3. 自定制页面展示效果

      ```python 
      class BookAdmin(admin.ModelAdmin):
          list_display = ['title', 'price', 'publish', "show_authors"]  # 定制展示的列
          list_display_links = ('price',)  # 定制跳转的列
          list_filter = ('publish', 'authors')  # 定制过滤列
          search_fields = ('title', 'price')  # 定制模糊搜索列
          # list_editable = ('title',)  # 定制可以直接编辑的列
          actions = ['patch_init']  # 定制批量处理方法
      
          def show_authors(self, obj):
              return " | ".join([i.name for i in obj.authors.all()])
      
          def patch_init(self, request, queryset):
              queryset.update(price=100)
      
          patch_init.short_description = "批量初始化"  # 设置操作名称
      
      
      admin.site.register(models.Book, BookAdmin)  # 方式一 常用的方法
      ```

   4. 注意url的变化

      ```python 
      http://127.0.0.1:8000/admin/app01/book/   # 获取所有数据
      http://127.0.0.1:8000/admin/app01/book/add/  # 新增一条数据
      http://127.0.0.1:8000/admin/app01/book/3/change/  # 修改一条数据
      http://127.0.0.1:8000/admin/app01/book/3/delete/  # 删除一条数据
              
      ```

4. Xadmin的使用

   1. 下载：(必须使用该命令)

   ```python 
   pip3 install https://codeload.github.com/sshwsfc/xadmin/zip/django2
   ```

   2. 在app里进行注册

      ```python
      INSTALLED_APPS = [
          'django.contrib.admin',
          'django.contrib.auth',
          'django.contrib.contenttypes',
          'django.contrib.sessions',
          'django.contrib.messages',
          'django.contrib.staticfiles',
      
          'xadmin',
          'crispy_forms',
          'reversion',
      
          'app01.apps.App01Config',
      ]
      ```

   3. 执行数据库迁移命令（两条命令）

   4. 在总路由中添加Xadmin的路由信息

      ```python 
      import xadmin
      xadmin.autodiscover()
      
      # version模块自动注册需要版本控制的 Model
      from xadmin.plugins import xversion
      xversion.register_models()
      
      urlpatterns = [
          path(r'xadmin/', xadmin.site.urls),
      ]
      ```

   5. 配置站点的全局配置

      ```python 
      import xadmin
      from xadmin import views
      
      
      class BaseSetting(object):
          """xadmin的基本配置"""
          enable_themes = True  # 开启主题切换功能
          use_bootswatch = True  # 引导控制菜单
      
      
      xadmin.site.register(views.BaseAdminView, BaseSetting)
      
      
      class GlobalSettings(object):
          """xadmin的全局配置"""
          site_title = "路飞学城"  # 设置站点标题
          site_footer = "路飞学城有限公司"  # 设置站点的页脚
          menu_style = "accordion"  # 设置菜单折叠
      
      
      xadmin.site.register(views.CommAdminView, GlobalSettings)
      ```

   6. 站点的model配置

      ```python 
      from .models import Book
      
      
      class BookAdminModel(object):
          # 控制列表展示的字段 设置默认展示字段
          list_display = ['title', 'price', 'pub_date', 'publish', 'authors']  
          # 控制可以通过搜索框搜索的字段名称，xadmin使用的是模糊查询
          search_fields = ['id', 'title', 'price']  
          # 可以进行过滤操作的列，对于分类、性别、状态
          list_filter = ['id', 'title', 'price', 'publish']  
          # 排序，默认升序
          ordering = ['-price']  
          # 展示详情信息的字段
          show_detail_fields = ['title']  
          # 设置允许直接在展示页编辑的字段
          list_editable = ['price']  
          # 设置列表页的刷新频率
          refresh_times = [3, 6, 30, 60]  
          # 控制列表页导出数据的可选格式，设置None来禁用数据导出功能
          list_export = ['xls', 'csv', 'json']  
          # 控制是否显示书签功能，False表示关闭
          show_bookmarks = True  
          # 显示图表数据
          data_charts = {
              'price_total': {
                  'title': '书籍单价曲线图',
                  'x-field': 'id',
                  'y-field': 'price',
                  'order': ('id',),
              },
              # 可以有多个图表
              # 'price_total2': {
              #     'title': '书籍单价曲线图2',
              #     'x-field': 'id',
              #     'y-field': 'price',
              #     'order': ('id',),
              # }
          }
          # 控制菜单的图标（图标的设置可以参考boostrap的图标css名称）
          model_icon = 'fa fa-gift'
          # 设置编辑页中只读字段
          readonly_fields = ['title']
          # 设置在编辑页隐藏的字段
          exclude = ['pub_date']
      
      
      xadmin.site.register(Book, BookAdminModel)
      ```

### 三. 本周作业

1. 图书管理系统，修改几条CBV，并且运用给CBV加上装饰器
2. 图书管理系统，加上分页器（书籍页用django自带，作者页用自定义的）
3. 练习admin和Xadmin常用的属性和方法。




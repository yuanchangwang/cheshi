### 推导式(comprehensions)

```
通过一行循环判断,遍历出一系列数据的方式是推导式
语法: val for val in Iterable (把想要的值写在 for的左侧)
里面是一行循环判断!根据套在推导式外层的符号判断具体是什么类型的推导式

推导式种类三种:
    [val for val in Iterable]  列表推导式
    {val for val in Iterable}  集合推导式
    {a:b for a,b in iterable}  字典推导式
```


### 列表推导式,集合推导式,字典推导式的相关写法

```
(1)普通推导式
(2)带有判断条件的推到式
(3)多循环推到式
(4)带有判断条件的多循环推到式
```

```
### (1)enumerate
enumerate(iterable,[start=0])
功能:枚举 ; 将索引号和iterable中的值,一个一个拿出来配对组成元组放入迭代器中
参数:
    iterable: 可迭代性数据 (常用:迭代器,容器类型数据,可迭代对象range) 
    start:  可以选择开始的索引号(默认从0开始索引)
返回值:迭代器
```
```
### (2)zip
zip(iterable, ... ...)
    功能: 将多个iterable中的值,一个一个拿出来配对组成元组放入迭代器中
    iterable: 可迭代性数据 (常用:迭代器,容器类型数据,可迭代对象range) 
返回: 迭代器
```

### 元组推导式是生成器(generator)

```
#元组推导式的返回值是一个生成器对象,简称生成器,生成器本质就是迭代器.

#迭代器和生成器区别:
	迭代器本身是系统内置的.重写不了.而生成器是用户自定义的,可以重写迭代逻辑

#生成器可以用两种方式创建:
    (1)生成器表达式  (里面是推导式,外面用圆括号)
    (2)生成器函数    (用def定义,里面含有yield)
```
```
# yield 类似于 return
共同点在于:执行到这句话都会把值返回出去
不同点在于:yield每次返回时,会记住上次离开时执行的位置 , 下次在调用生成器 , 会从上次执行的位置往下走
		   而return直接终止函数,每次重头调用.
yield 6 和 yield(6) 2种写法都可以 yield 6 更像 return 6 的写法 推荐使用
```
### 生成器send 与 yield from
```
### send
# next和send区别:
	next 只能取值
	send 不但能取值,还能发送值
# send注意点:
	第一个 send 不能给 yield 传值 默认只能写None
	最后一个yield 接受不到send的发送值
	
### yield from : 将一个可迭代对象变成一个迭代器返回	
```
### 练习题:

```
(1).{'x': 'A', 'y': 'B', 'z': 'C' } 把字典写成x=A,y=B,z=C的列表推导式
(2).把列表中所有字符变成小写  ["ADDD","dddDD","DDaa","sss"]
(3).x是0-5之间的偶数,y是0-5之间的奇数 把x,y组成一起变成元组,放到列表当中
(4).使用列表推导式 制作所有99乘法表中的运算
(5)#求M,N中矩阵和元素的乘积
# M = [ [1,2,3], 
#       [4,5,6], 
#       [7,8,9]  ] 

# N = [ [2,2,2], 
#       [3,3,3], 
#       [4,4,4]  ] 
=>实现效果1   [2, 4, 6, 12, 15, 18, 28, 32, 36]
=>实现效果2   [[2, 4, 6], [12, 15, 18], [28, 32, 36]]
```